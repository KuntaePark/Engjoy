using System.Collections;
using System.Collections.Generic;
using DataForm;
using TMPro;
using UnityEngine;

public class MonsterController : MonoBehaviour
{
   //현재 2025년 07월 02일 오전 10시 46분
   //속이 Monster같이 날뛰고 있다.
   //카페인은 사람을 찢는다.

    public string Id { get; private set; }
    public int Hp {  get; private set; }
    public string Type {  get; private set; }
    public bool isActive { get; private set; }

    [SerializeField] private TextMeshPro hpText; // ◀◀◀ HP를 표시할 텍스트 (테스트용_후에 HP바로 변경)
    private SpriteRenderer spriteRenderer;

    private Vector3 targetPosition;
    private float positionLerpFactor = 15f;


    public void Awake()
    {
        spriteRenderer = GetComponent<SpriteRenderer>();
    }


    public void Initialize(string id, MonsterData initialData)
    {
        Id = id;
        transform.position = new Vector3(initialData.x, initialData.y, 0);
        targetPosition = transform.position;

        //초기 데이터로 상태 업데이트
        UpdateState(initialData);
    }

    public void UpdateState(MonsterData data)
    {
        //서버로부터 받은 새 위치를 목표 위치로 설정
        targetPosition = new Vector3(data.x, data.y, 0);

        //HP상태 업데이트
        if(data.hp < this.Hp)
        {
            //피격 판정의 시각적 효과
            StartCoroutine(TakeDamageEffect());
        }

        
        this.Hp = data.hp;
        if(hpText != null)
        {
            hpText.text = ""+this.Hp;
        }


        
        Type = data.type;
        isActive = data.isActive;

        UpdateVisibility();
    }

    void UpdateVisibility()
    {
        bool visible = true; //기본값은 보임

        if (Type == "chaser")
        {
            visible = isActive; //Chaser는 활성화 상태일 때만 보임
        }

        if (spriteRenderer != null) spriteRenderer.enabled = visible;
        if(hpText != null) hpText.enabled = visible;
    }

    private IEnumerator TakeDamageEffect()
    {
        if(spriteRenderer == null) yield break;

        spriteRenderer.color = Color.red;
        yield return new WaitForSeconds(0.15f);
        spriteRenderer.color = Color.white;
    }

    private void Update()
    {
        //목표 위치로 부드럽게 이동시켜주기
        transform.position = Vector3.Lerp(transform.position, targetPosition, Time.deltaTime * positionLerpFactor);
    }
}
